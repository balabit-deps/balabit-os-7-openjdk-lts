diffhotspot/src/os/linux/vm/jsig.c b/hotspot/src/os/linux/vm/jsig.c
Index: b/src/java.base/linux/native/libjsig/jsig.c
===================================================================
--- a/src/java.base/linux/native/libjsig/jsig.c
+++ b/src/java.base/linux/native/libjsig/jsig.c
@@ -41,13 +41,8 @@
 #define true 1
 #define false 0
 
-#define MASK(sig) ((uint64_t)1 << (sig-1))  // 0 is not a signal.
-// Check whether all signals fit into jvmsigs. -1 as MASK shifts by -1.
-#if (64 < NSIG-1)
-#error "Not all signals can be encoded in jvmsigs. Adapt its type!"
-#endif
 static struct sigaction sact[NSIG]; /* saved signal handlers */
-static uint64_t jvmsigs = 0; /* signals used by jvm */
+static sigset_t jvmsigs; /* signals used by jvm */
 
 /* used to synchronize the installation of signal handlers */
 static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -65,6 +60,11 @@ static sigaction_t os_sigaction = 0; /*
 static bool jvm_signal_installing = false;
 static bool jvm_signal_installed = false;
 
+static __attribute__((constructor)) void jvmsigs_init(void)
+{
+    sigemptyset(&jvmsigs);
+}
+
 static void signal_lock() {
   pthread_mutex_lock(&mutex);
   /* When the jvm is installing its set of signal handlers, threads
@@ -110,7 +110,7 @@ static sa_handler_t set_signal(int sig,
 
   signal_lock();
 
-  sigused = (sig < NSIG) && ((MASK(sig) & jvmsigs) != 0);
+  sigused = (sig < NSIG) && sigismember(&jvmsigs, sig);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
@@ -127,7 +127,7 @@ static sa_handler_t set_signal(int sig,
     save_signal_handler(sig, oldhandler);
 
     /* Record the signals used by jvm */
-    jvmsigs |= MASK(sig);
+    sigaddset(&jvmsigs, sig);
 
     signal_unlock();
     return oldhandler;
@@ -168,7 +168,7 @@ int sigaction(int sig, const struct siga
 
   signal_lock();
 
-  sigused = (sig < NSIG) && ((MASK(sig) & jvmsigs) != 0);
+  sigused = (sig < NSIG) && sigismember(&jvmsigs, sig);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
@@ -191,7 +191,7 @@ int sigaction(int sig, const struct siga
     }
 
     /* Record the signals used by jvm */
-    jvmsigs |= MASK(sig);
+    sigaddset(&jvmsigs, sig);
 
     signal_unlock();
     return res;
@@ -223,7 +223,7 @@ void JVM_end_signal_setting() {
 
 struct sigaction *JVM_get_signal_action(int sig) {
   /* Does race condition make sense here? */
-  if ((MASK(sig) & jvmsigs) != 0) {
+  if (sigismember(&jvmsigs, sig)) {
     return &sact[sig];
   }
   return NULL;
Index: b/src/hotspot/os/linux/os_linux.cpp
===================================================================
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -4411,14 +4411,16 @@ bool os::Linux::signal_handlers_are_inst
 
 // For signal-chaining
 struct sigaction sigact[NSIG];
-uint64_t sigs = 0;
-#if (64 < NSIG-1)
-#error "Not all signals can be encoded in sigs. Adapt its type!"
-#endif
+sigset_t sigs;
 bool os::Linux::libjsig_is_loaded = false;
 typedef struct sigaction *(*get_signal_t)(int);
 get_signal_t os::Linux::get_signal_action = NULL;
 
+static __attribute__((constructor)) void sigs_init()
+{
+    sigemptyset(&sigs);
+}
+
 struct sigaction* os::Linux::get_chained_signal_action(int sig) {
   struct sigaction *actp = NULL;
 
@@ -4493,7 +4495,7 @@ bool os::Linux::chained_handler(int sig,
 }
 
 struct sigaction* os::Linux::get_preinstalled_handler(int sig) {
-  if ((((uint64_t)1 << (sig-1)) & sigs) != 0) {
+  if (sigismember(&sigs, sig)) {
     return &sigact[sig];
   }
   return NULL;
@@ -4502,7 +4504,7 @@ struct sigaction* os::Linux::get_preinst
 void os::Linux::save_preinstalled_handler(int sig, struct sigaction& oldAct) {
   assert(sig > 0 && sig < NSIG, "vm signal out of expected range");
   sigact[sig] = oldAct;
-  sigs |= (uint64_t)1 << (sig-1);
+  sigaddset(&sigs, sig);
 }
 
 // for diagnostic
